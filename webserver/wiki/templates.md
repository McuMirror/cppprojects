[...оглавление](./main.md)

#### Использование go-templates

<!-- import "text/template"
Обзор
Индекс
Примеры
Подкаталоги -->

#####Обзор

Пакет шаблонизатора go реализует управляемые данными шаблоны для создания текстового вывода.
Чтобы сгенерировать вывод HTML, см. *package html/template*, который имеет тот же интерфейс, что и этот пакет, но автоматически защищает вывод HTML от определенных атак.

Шаблоны выполняются путем применения их к структуре данных. Аннотации в шаблоне относятся к элементам структуры данных (обычно к полю структуры или ключу хеш массива) для управления выполнением и получения значений для отображения. Выполнение шаблона проходит по структуре и устанавливает курсор, представленный точкой '.' и называется **«dot»**, к значению в текущем месте в структуре по мере выполнения.

Входным текстом для шаблона является текст в кодировке UTF-8 в любом формате. **«Actions»** - оценки данных или управляющие структуры - разделяются «{{» и «}}»; весь текст вне действий копируется в вывод без изменений, за исключением необработанных строк, действия которых не могут охватывать символы новой строки, хотя при этом комментарии могут.

После синтаксического анализа шаблон может безопасно выполняться параллельно, хотя, если параллельное выполнение совместно использует Writer, вывод может чередоваться.

Вот банальный пример, что выводит «17 вещей из шерсти».
```
type Inventory struct {
	Material string
	Count    uint
}
sweaters := Inventory{"wool", 17}
tmpl, err := template.New("test").Parse("{{.Count}} items are made of {{.Material}}")
if err != nil { panic(err) }
err = tmpl.Execute(os.Stdout, sweaters)
if err != nil { panic(err) }
```
Далее приведены более сложные примеры.

#####Текст и пробелы
По умолчанию весь текст между **Actions** копируется дословно при выполнении шаблона. Например, строка «items are made of» в приведенном выше примере появляется в стандартном выводе при запуске программы.

Однако, чтобы помочь в форматировании исходного кода шаблона, если за левым разделителем действия (по умолчанию "{{") сразу же следует знак минус и символ пробела ASCII ("{{-"), все конечные пробелы удаляются из непосредственно предшествующий текст. Точно так же, если правому разделителю ("}}") предшествует пробел и знак минус ("-}}"), все начальные пробелы удаляются из следующего текста. В этих маркерах обрезки должен присутствовать пробел ASCII; "{{-3}}" анализируется как действие, содержащее число -3.

Например, при выполнении шаблона, источником которого является
```
"{{23 -}} <{{- 45}}"
```
сгенерированный вывод будет
```
«23 <45»
```
Для этой обрезки определение пробелов такое же, как в Go: пробел, горизонтальная табуляция, возврат каретки и новая строка.

#####Actions - Действия
Вот список действий. «Arguments» и «Pipelines» - это оценки данных, подробно описанные в соответствующих разделах ниже.
```
{{/* a comment */}}
{{- / * комментарий с обрезанным пробелом между предшествующим и последующим текстом * / -}}
	Комментарий; отброшен. Может содержать символы новой строки.
	Комментарии не вкладываются и должны начинаться и заканчиваться на
	разделители, как показано здесь.

{{pipeline}}
	Текстовое представление по умолчанию (то же, что и
	напечатано fmt.Print) значение конвейера копируется
	к выходу.

{{if pipeline}} T1 {{end}}
	Если значение конвейера пусто, выход не создается;
	в противном случае выполняется T1. Пустые значения - false, 0, любые
	указатель nil или значение интерфейса, а также любой массив, срез, карта или
	строка нулевой длины.
	На точку это не влияет.

{{if pipeline}} T1 {{else}} T0 {{end}}
	Если значение конвейера пусто, выполняется T0;
	в противном случае выполняется T1. На точку это не влияет.

{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}
	Чтобы упростить внешний вид цепочек if-else, действие else
	if может включать другое if напрямую; эффект точно
	то же, что и письмо
		{{если конвейер}} T1 {{else}} {{если конвейер}} T0 {{end}} {{end}}

{{range pipeline}} T1 {{end}}
	Значение конвейера должно быть массивом, фрагментом, картой или каналом.
	Если значение конвейера имеет нулевую длину, ничего не выводится;
	в противном случае точка устанавливается для последовательных элементов массива,
	slice или map и выполняется T1. Если значение - это карта, а
	ключи базового типа с определенным порядком, элементы будут
	посещены в отсортированном ключевом порядке.

{{range pipeline}} T1 {{else}} T0 {{end}}
	Значение конвейера должно быть массивом, фрагментом, картой или каналом.
	Если значение конвейера имеет нулевую длину, точка не изменяется и
	T0 выполняется; в противном случае точка устанавливается для последовательных элементов
	массива, фрагмента или карты, и выполняется T1.

{{template "name"}}
	Шаблон с указанным именем выполняется с нулевыми данными.

{{template "name" pipeline}}
	Шаблон с указанным именем выполняется с установленной точкой
	к стоимости трубопровода.

{{block "name" pipeline}} T1 {{end}}
	Блок - это сокращение для определения шаблона
		{{определить "имя"}} T1 {{end}}
	а затем выполнить его на месте
		{{шаблон "название" конвейера}}
	Типичное использование - определение набора корневых шаблонов, которые
	затем настроить, переопределив шаблоны блоков внутри.

{{with pipeline}} T1 {{end}}
	Если значение конвейера пусто, выход не создается;
	в противном случае точка устанавливается на значение конвейера, а T1 -
	выполнен.

{{with pipeline}} T1 {{else}} T0 {{end}}
	Если значение конвейера пусто, точка не изменяется и T0
	выполняется; в противном случае точка устанавливается на значение конвейера
	и T1 выполняется.
```
#####Аргументы
Аргумент - это простое значение, обозначаемое одним из следующих значений.
```
- Логическое, строковое, символьное, целое, с плавающей запятой, мнимое
  или сложная константа в синтаксисе Go. Они ведут себя как нетипизированные Go
  константы. Обратите внимание, что, как и в Go, большая целочисленная константа
  переполнение при назначении или передаче функции может зависеть от того,
  int на главной машине - 32- или 64-битные.
- Ключевое слово nil, представляющее нетипизированный Go nil.
- Символ '.' (период):
	.
  Результат - значение точки.
- Имя переменной, представляющее собой (возможно, пустую) буквенно-цифровую строку.
  перед знаком доллара, например
	$ piOver2
  или
	$
  Результат - значение переменной.
  Переменные описаны ниже.
- Имя поля данных, которое должно быть структурой, перед
  на период, например
	.Field
  Результат - значение поля. Вызовы полей могут быть
  сцеплены:
    .Field1.Field2
  Поля также можно оценивать по переменным, включая цепочки:
    $ x.Field1.Field2
- Имя ключа данных, которым должен быть хешмассив, например
	.Key
  Результатом является значение элемента хеш массива, проиндексированное ключом.
  Ключевые вызовы могут быть связаны и объединены с полями для любых
  глубина:
    .Field1.Key1.Field2.Key2
  Хотя ключ должен быть буквенно-цифровым идентификатором, в отличие от
  имена полей не должны начинаться с заглавной буквы.
  Ключи также можно оценивать по переменным, включая цепочки:
    $ x.key1.key2
- Имя ниладического метода данных, которому предшествует точка,
  Такие как
	.Method
  Результат - значение вызова метода с точкой в ​​качестве
  приемника, dot.Метод (). Такой метод должен иметь одно возвращаемое значение (из
  любой тип) или два возвращаемых значения, второе из которых является ошибкой.
  Если их два и возвращенная ошибка не равна нулю, выполнение прекращается.
  и вызывающей стороне возвращается ошибка как значение Execute.
  Вызовы методов могут быть связаны и объединены с полями и ключами.
  на любую глубину:
    .Field1.Key1.Method1.Field2.Key2.Method2
  Методы также можно оценивать по переменным, включая цепочки:
    $ x.Method1.Field
- Имя ниладической функции, например
	fun
  Результат - значение вызова функции fun (). Возврат
  типы и значения ведут себя как в методах. Функции и функции
  имена описаны ниже.
- Экземпляр одного из указанных выше в скобках для группировки. Результат
  может быть доступен с помощью вызова поля или ключа хеш массива.
	print (.F1 arg1) (.F2 arg2)
	(.StructValuedMethod "arg").Field
```
Аргументы могут быть любого типа. Если это указатели, реализация при необходимости автоматически обращается к базовому типу. Если приведение дает значение функции, такое как поле со значением функции структуры, функция не вызывается автоматически, но ее можно использовать как значение истины для действия if и т.п. Чтобы вызвать его, используйте функцию call, определенную ниже.

#####Конвейеры
Конвейер - это возможно связанной последовательность «команд». Команда - это простое значение (аргумент) или вызов функции или метода, возможно, с несколькими аргументами:

```
Argument
	Результат - значение оценки аргумента.
.Method [Argument ...]
	Метод может быть единственным или последним элементом цепочки, но,
	в отличие от методов в середине цепочки, он может принимать аргументы.
	Результат - значение вызова метода с
	аргументы:
		dot.Method (Аргумент1 и т. д.)
functionName [Argument ...]
	Результат - значение вызова связанной функции
	с названием:
		функция (Аргумент1 и т. д.)
	Функции и названия функций описаны ниже.
```
Конвейер можно «связать», разделив последовательность команд символами конвейера '|'. В связанном конвейере результат каждой команды передается как последний аргумент следующей команды. Результатом последней команды конвейера является значение конвейера.

На выходе команды будет либо одно значение, либо два значения, второе из которых имеет ошибку типа. Если это второе значение присутствует и оценивается как ненулевое, выполнение прекращается, и ошибка возвращается вызывающей стороне Execute.

#####Переменные
Конвейер внутри действия может инициализировать переменную для хранения результата. Инициализация имеет синтаксис
```
$variable := pipeline
```
где $variable - это имя переменной. Действие, объявляющее переменную, не производит никаких результатов.

Ранее объявленные переменные также могут быть присвоены с помощью синтаксиса
```
$variable = pipeline
```
Если действие «range» инициализирует переменную, переменная устанавливается равной последовательным элементам итерации. Кроме того, "range" может объявлять две переменные, разделенные запятой:
```
range $index, $element := pipeline
```

в этом случае $index и $element устанавливаются на последовательные значения индекса массива/фрагмента или ключа и элемента хеш массива, соответственно. Обратите внимание, что если есть только одна переменная, и ей присваивается элемент, то это противоречит соглашению в предложениях Go о range.

Область действия переменной расширяется до «end» действия структуры управления («if», «with» или «range»), в котором она объявлена, или до конца шаблона, если такой структуры управления нет. Вызов шаблона не наследует переменные с момента его вызова.

Когда выполнение начинается, $ устанавливается в аргумент данных, переданный в Execute, то есть в начальное значение точки.

#####Примеры
Вот несколько примеров однострочных шаблонов, демонстрирующих конвейеры и переменные. Все производят процитированное слово «output»:
```
{{"\"output\""}}
	A string constant.
{{`"output"`}}
	A raw string constant.
{{printf "%q" "output"}}
	A function call.
{{"output" | printf "%q"}}
	A function call whose final argument comes from the previous
	command.
{{printf "%q" (print "out" "put")}}
	A parenthesized argument.
{{"put" | printf "%s%s" "out" | printf "%q"}}
	A more elaborate call.
{{"output" | printf "%s" | printf "%q"}}
	A longer chain.
{{with "output"}}{{printf "%q" .}}{{end}}
	A with action using dot.
{{with $x := "output" | printf "%q"}}{{$x}}{{end}}
	A with action that creates and uses a variable.
{{with $x := "output"}}{{printf "%q" $x}}{{end}}
	A with action that uses the variable in another action.
{{with $x := "output"}}{{$x | printf "%q"}}{{end}}
	The same, but pipelined.
```
    
#####Функции
Во время выполнения функции находятся в двух элемента массива функций: сначала в шаблоне, затем в глобальной хеше функций. По умолчанию в шаблоне не определены функции, но для их добавления можно использовать метод Funcs.

Предопределенные глобальные функции имеют следующие названия.
```
and
	Возвращает логическое И своих аргументов, возвращая
	первый пустой аргумент или последний аргумент, то есть
	«и х у» ведет себя как «если х, то у иначе х». Все
	аргументы оцениваются.
call
	Возвращает результат вызова первого аргумента, который
	должен быть функцией с остальными аргументами в качестве параметров.
	Таким образом, "call .XY 1 2" в нотации Go означает dot.XY (1, 2), где
	Y - это поле со значением func, запись карты и т.п.
	Первый аргумент должен быть результатом оценки
	который дает значение типа функции (в отличие от
	предопределенная функция, такая как печать). Функция должна
	вернуть одно или два значения результата, второе из которых
	имеет тип ошибки. Если аргументы не соответствуют функции
	или возвращаемое значение ошибки не равно нулю, выполнение останавливается.
html
	Возвращает экранированный HTML-эквивалент текстового
	представление своих аргументов. Эта функция недоступна
	в html / template, за некоторыми исключениями.
index
	Возвращает результат индексации своего первого аргумента
	следующие аргументы. Таким образом, "index x 1 2 3" в синтаксисе Go:
	х [1] [2] [3]. Каждый проиндексированный элемент должен быть картой, фрагментом или массивом.
slice
	slice возвращает результат нарезки своего первого аргумента на
	оставшиеся аргументы. Таким образом, "slice x 1 2" в синтаксисе Go равен x [1: 2],
	в то время как «slice x» - это x [:], «slice x 1» - это x [1:], а «slice x 1 2 3»
	это x [1: 2: 3]. Первый аргумент должен быть строкой, фрагментом или массивом.
js
	Возвращает экранированный JavaScript-эквивалент текстового
	представление своих аргументов.
len
	Возвращает целое число своего аргумента.
not
	Возвращает логическое отрицание своего единственного аргумента.
or
	Возвращает логическое ИЛИ своих аргументов, возвращая
	первый непустой аргумент или последний аргумент, то есть
	"или x y" ведет себя как "если x, то x, иначе y". Все
	аргументы оцениваются.
print
	Псевдоним для fmt.Sprint
printf
	Псевдоним для fmt.Sprintf
println
	Псевдоним для fmt.Sprintln
urlquery
	Возвращает экранированное значение текстового представления
	его аргументы в форме, подходящей для встраивания в URL-запрос.
	Эта функция недоступна в html / template из-за некоторых
	исключений.
```

Логические функции принимают любое нулевое значение за ложь и ненулевое значение за истину.

Также существует набор операторов двоичного сравнения, определенных как функции:
```
eq
	Возвращает логическую истину arg1 == arg2
ne
	Возвращает логическую истину arg1! = Arg2
lt
	Возвращает логическую истину arg1 <arg2
ле
	Возвращает логическую истину arg1 <= arg2
gt
	Возвращает логическую истину arg1> arg2
ge
	Возвращает логическую истину arg1> = arg2
```
Для более простых многосторонних тестов на равенство eq (only) принимает два или более аргумента и сравнивает второй и последующий с первым, возвращая в действительности
```
arg1 == arg2 || arg1 == arg3 || arg1 == arg4 ...
```
(Однако, в отличие от || в Go, eq - это вызов функции, и все аргументы будут вычислены.)

Функции сравнения работают с любыми значениями, тип которых Go определяет как сопоставимые. Для основных типов, таких как целые числа, правила смягчены: размер и точный тип игнорируются, поэтому любое целочисленное значение, знаковое или беззнаковое, можно сравнивать с любым другим целочисленным значением. (Сравнивается арифметическое значение, а не битовый шаблон, поэтому все отрицательные целые числа меньше, чем все целые числа без знака.) Однако, как обычно, нельзя сравнивать int с float32 и так далее.

#####Связанные шаблоны
Каждый шаблон именован строкой, указанной при его создании. Кроме того, каждый шаблон связан с нулевым или несколькими другими шаблонами, которые он может вызывать по имени; такие ассоциации являются переходными и образуют пространство имен шаблонов.

Шаблон может использовать вызов шаблона для создания другого связанного шаблона (см. объяснение действия "шаблон" выше). Имя должно совпадать с именем шаблона, связанного с шаблоном, содержащим вызов.

#####Определения вложенных шаблонов
При синтаксическом анализе шаблона может быть определен другой шаблон, связанный с анализируемым шаблоном. Определения шаблона должны появляться на верхнем уровне шаблона, как глобальные переменные в программе Go.

Синтаксис таких определений заключается в том, чтобы окружать каждое объявление шаблона действием «определить» и «завершить».

Действие определения именует создаваемый шаблон, предоставляя строковую константу. Вот простой пример:
```
`{{define "T1"}}ONE{{end}}
{{define "T2"}}TWO{{end}}
{{define "T3"}}{{template "T1"}} {{template "T2"}}{{end}}
{{template "T3"}}`
```
Это определяет два шаблона, T1 и T2, и третий T3, который вызывает два других при выполнении. Наконец, он вызывает T3. При выполнении этот шаблон создаст текст
```
ONE TWO
```
По конструкции шаблон может находиться только в одной ассоциации. Если необходимо иметь шаблон, доступный из нескольких ассоциаций, определение шаблона должно быть проанализировано несколько раз для создания различных *Template значений, или должно быть скопировано с помощью метода Clone или AddParseTree.

Parse можно вызывать несколько раз для сборки различных связанных шаблонов; см. функции и методы ParseFiles и ParseGlob, чтобы узнать о простых способах анализа связанных шаблонов, хранящихся в файлах.

Шаблон может выполняться напрямую или через ExecuteTemplate, который выполняет связанный шаблон, идентифицированный по имени. Чтобы вызвать наш пример выше, мы могли бы написать,
```
err := tmpl.Execute(os.Stdout, "no data needed")
if err != nil {
	log.Fatalf("execution failed: %s", err)
}
```
или для явного вызова определенного шаблона по имени,
```
err := tmpl.ExecuteTemplate(os.Stdout, "T2", "no data needed")
if err != nil {
	log.Fatalf("execution failed: %s", err)
}
````
[...package template](https://golang.org/pkg/text/template/#pkg-index)
[...примеры](https://golang.org/pkg/text/template/#pkg-index)