#include "cardreader/vendotek/Tlv.h"
#include "cardreader/vendotek/VendotekProtocol.h"
#include "test/include/Test.h"
#include "logger/include/Logger.h"

class TlvTest : public TestSet {
public:
	TlvTest();
	bool testHeaderParse();
	bool testPacketMakerDateTime();
	bool testPacketMakerData();
	bool testPacketLongValue();
};

TEST_SET_REGISTER(TlvTest);

TlvTest::TlvTest() {
	TEST_CASE_REGISTER(TlvTest, testHeaderParse);
	TEST_CASE_REGISTER(TlvTest, testPacketMakerDateTime);
	TEST_CASE_REGISTER(TlvTest, testPacketMakerData);
	TEST_CASE_REGISTER(TlvTest, testPacketLongValue);
}

bool TlvTest::testHeaderParse() {
	uint8_t d1[] = { 0x01, 0x02, 0x03, 0x04 };
	Tlv::Header *h1 = (Tlv::Header*)d1;
	uint32_t h1Len, v1Len;
	TEST_NUMBER_EQUAL(true, h1->parse(sizeof(d1), &h1Len, &v1Len));
	TEST_NUMBER_EQUAL(2, h1Len);
	TEST_NUMBER_EQUAL(2, v1Len);
	TEST_NUMBER_EQUAL(2, h1->getValueLen());

	uint8_t d2[] = { 0x01, 0x81, 0xF1, 0x03, 0x04 };
	Tlv::Header *h2 = (Tlv::Header*)d2;
	uint32_t h2Len, v2Len;
	TEST_NUMBER_EQUAL(true, h2->parse(244, &h2Len, &v2Len));
	TEST_NUMBER_EQUAL(3, h2Len);
	TEST_NUMBER_EQUAL(241, v2Len);
	TEST_NUMBER_EQUAL(241, h2->getValueLen());

	uint8_t d3[] = { 0x01, 0x82, 0x02, 0x00, 0x03, 0x04 };
	Tlv::Header *h3 = (Tlv::Header*)d3;
	uint32_t h3Len, v3Len;
	TEST_NUMBER_EQUAL(true, h3->parse(516, &h3Len, &v3Len));
	TEST_NUMBER_EQUAL(4, h3Len);
	TEST_NUMBER_EQUAL(512, v3Len);
	TEST_NUMBER_EQUAL(512, h3->getValueLen());
	return true;
}

bool TlvTest::testPacketMakerDateTime() {
	Tlv::PacketMaker maker(512);
	DateTime datetime1;
	datetime1.year = 20;
	datetime1.month = 3;
	datetime1.day = 16;
	datetime1.hour = 16;
	datetime1.minute = 28;
	datetime1.second = 35;
	maker.addDateTime(0x11, &datetime1);
	TEST_HEXDATA_EQUAL("11143230323030333136543133323833352B30333030", maker.getData(), maker.getDataLen());
	return true;
}

bool TlvTest::testPacketMakerData() {
	Tlv::PacketMaker resp(1024);
	uint8_t dest[] = { 0x00 };
	uint8_t data[] = {
		0x16, 0x03, 0x03, 0x00, 0x41, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x03, 0x5E, 0x94, 0x27, 0xBC, 0xF2,
		0x8E, 0x7E, 0x8A, 0xC2, 0x7F, 0x85, 0x85, 0x5D, 0x2C, 0x3E, 0x1A, 0xC9, 0x36, 0x57, 0x46, 0x45,
		0x5D, 0xE7, 0x3C, 0x7F, 0x31, 0xF1, 0xDE, 0xBE, 0xE8, 0xFB, 0xD2, 0x00, 0xC0, 0x2F, 0x00, 0x00,
		0x15, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0B, 0x00, 0x04, 0x03, 0x00,

		0x01, 0x02, 0x00, 0x23, 0x00, 0x00, 0x16, 0x03, 0x03, 0x0D, 0x44, 0x0B, 0x00, 0x0D, 0x40, 0x00,
		0x0D, 0x3D, 0x00, 0x06, 0x05, 0x30, 0x82, 0x06, 0x01, 0x30, 0x82, 0x03, 0xE9, 0xA0, 0x03, 0x02,
		0x01, 0x02, 0x02, 0x02, 0x10, 0x00, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D,
		0x01, 0x01, 0x0B, 0x05, 0x00, 0x30, 0x81, 0xA4, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,

		0x06, 0x13, 0x02, 0x52, 0x55, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x06,
		0x4D, 0x6F, 0x73, 0x63, 0x6F, 0x77, 0x31, 0x0F, 0x30, 0x0D, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13,
		0x06, 0x4D, 0x6F, 0x73, 0x63, 0x6F, 0x77, 0x31, 0x1B, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x0A,
		0x13, 0x12, 0x42, 0x50, 0x43, 0x20, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67,

		0x20, 0x4C, 0x4C, 0x43, 0x31, 0x1A, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x11, 0x50,
		0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x65, 0x6E, 0x74, 0x72, 0x65,
		0x31, 0x1B, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x12, 0x54, 0x45, 0x53, 0x54, 0x20,
		0x50, 0x4F, 0x53, 0x20, 0x43, 0x41, 0x20, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x31, 0x1D, 0x30,

		0x1B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x01, 0x16, 0x0E, 0x69, 0x6E,
		0x66, 0x6F, 0x40, 0x62, 0x70, 0x63, 0x62, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x1E, 0x17, 0x0D,
		0x31, 0x39, 0x31, 0x31, 0x30, 0x37, 0x31, 0x33, 0x31, 0x38, 0x35, 0x35, 0x5A, 0x17, 0x0D, 0x32,
		0x39, 0x31, 0x31, 0x30, 0x34, 0x31, 0x33, 0x31, 0x38, 0x35, 0x35, 0x5A, 0x30, 0x81, 0x8C, 0x31,

		0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x52, 0x55, 0x31, 0x0F, 0x30, 0x0D,
		0x06, 0x03, 0x55, 0x04, 0x08, 0x0C, 0x06, 0x4D, 0x6F, 0x73, 0x63, 0x6F, 0x77, 0x31, 0x0F, 0x30,
		0x0D, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0C, 0x06, 0x4D, 0x6F, 0x73, 0x63, 0x6F, 0x77, 0x31, 0x1B,
		0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x0C, 0x12, 0x4C, 0x4C, 0x43, 0x20, 0x42, 0x50, 0x43,

		0x20, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x31, 0x1A, 0x30, 0x18, 0x06,
		0x03, 0x55, 0x04, 0x0B, 0x0C, 0x11, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67,
		0x20, 0x43, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x31, 0x22, 0x30, 0x20, 0x06, 0x03, 0x55, 0x04, 0x03,
		0x0C, 0x19, 0x70, 0x31, 0x2D, 0x74, 0x65, 0x73, 0x74, 0x2E, 0x62, 0x70, 0x63, 0x70, 0x72, 0x6F,

		0x63, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x2E, 0x63, 0x6F, 0x6D, 0x30, 0x82, 0x02, 0x22, 0x30,
		0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82,
		0x02, 0x0F, 0x00, 0x30, 0x82, 0x02, 0x0A, 0x02, 0x82, 0x02, 0x01, 0x00, 0xEE, 0xC4, 0x0F, 0x83,
		0x70, 0x90, 0x52, 0xB2, 0x4A, 0xBE, 0x6A, 0xBA, 0x8B, 0x34, 0x8B, 0x31, 0x35, 0xAB, 0x04, 0x4C,
	};


	resp.clear();
	resp.addString(Vendotek::Type_MessageName, "DAT");
	TEST_HEXDATA_EQUAL(
		"0103444154"// MessageName=DAT
		, resp.getData(), resp.getDataLen());

	resp.addData(Vendotek::Type_TcpIpDestination, dest, sizeof(dest));
	TEST_HEXDATA_EQUAL(
		"0103444154"// MessageName=DAT
		"0B0100" // TcpIpDestination = 0
		, resp.getData(), resp.getDataLen());

	resp.addData(Vendotek::Type_SimpleDataBlock, data, sizeof(data));
	TEST_HEXDATA_EQUAL(
		"0103444154"// MessageName=DAT
		"0B0100" // TcpIpDestination = 0
		"0D820200" // SimpleDataBlock=298
		"16030300410200003D03035E9427BCF2"
		"8E7E8AC27F85855D2C3E1AC936574645"
		"5DE73C7F31F1DEBEE8FBD200C02F0000"
		"1500000000FF01000100000B00040300"
		"0102002300001603030D440B000D4000"
		"0D3D00060530820601308203E9A00302"
		"010202021000300D06092A864886F70D"
		"01010B05003081A4310B300906035504"
		"0613025255310F300D06035504081306"
		"4D6F73636F77310F300D060355040713"
		"064D6F73636F77311B3019060355040A"
		"13124250432050726F63657373696E67"
		"204C4C43311A3018060355040B131150"
		"726F63657373696E672043656E747265"
		"311B3019060355040313125445535420"
		"504F5320434120534841323536311D30"
		"1B06092A864886F70D010901160E696E"
		"666F4062706362742E636F6D301E170D"
		"3139313130373133313835355A170D32"
		"39313130343133313835355A30818C31"
		"0B3009060355040613025255310F300D"
		"06035504080C064D6F73636F77310F30"
		"0D06035504070C064D6F73636F77311B"
		"3019060355040A0C124C4C4320425043"
		"2050726F63657373696E67311A301806"
		"0355040B0C1150726F63657373696E67"
		"2043656E746572312230200603550403"
		"0C1970312D746573742E62706370726F"
		"63657373696E672E636F6D3082022230"
		"0D06092A864886F70D01010105000382"
		"020F003082020A0282020100EEC40F83"
		"709052B24ABE6ABA8B348B3135AB044C"
		, resp.getData(), resp.getDataLen());
	return true;
}

bool TlvTest::testPacketLongValue() {
	Tlv::Packet packet(20);
	const char hex[] =
		"0103444154" // MessageName=DAT
		"0B0100" // TcpIpDestination = 0
		"0C03323938" // OutgoingByteCounter = 298
		"0D82012A" // SimpleDataBlock=130
		"16030101250100012103035E786B64FD"
		"AA1421C01D2FE623865B7F8EDDAA0231"
		"E054DE18C587623D169EC100009EC02C"
		"C030009FC0ADC09FC024C028006BC00A"
		"C0140039C0AFC0A3C02BC02F009EC0AC"
		"C09EC023C0270067C009C0130033C0AE"
		"C0A200ABC0A7C03800B3C0360091C0AB"
		"00AAC0A6C03700B2C0350090C0AA009D"
		"C09D003D0035C032C02AC00FC02EC026"
		"C005C0A1009CC09C003C002FC031C029"
		"C00EC02DC025C004C0A000AD00B70095"
		"00AC00B6009400A9C0A500AF008DC0A9"
		"00A8C0A400AE008CC0A800FF0100005A"
		"0000000E000C0000093132372E302E30"
		"2E31000D001600140603060105030501"
		"040304010303030102030201000A0018"
		"00160019001C0018001B00170016001A"
		"0015001400130012000B000201000016"
		"00000017000000230000";

	uint8_t data[512];
	uint16_t dataLen = hexToData(hex, strlen(hex), data, sizeof(data));
	packet.parse((uint8_t*)data, dataLen);

	uint8_t buf[512];
	TEST_NUMBER_EQUAL(3, packet.getData(0x01, buf, sizeof(buf)));
	TEST_HEXDATA_EQUAL("444154", buf, 3);
	TEST_NUMBER_EQUAL(1, packet.getData(0x0B, buf, sizeof(buf)));
	TEST_HEXDATA_EQUAL("00", buf, 1);
	TEST_NUMBER_EQUAL(3, packet.getData(0x0C, buf, sizeof(buf)));
	TEST_HEXDATA_EQUAL("323938", buf, 3);
	TEST_NUMBER_EQUAL(298, packet.getData(0x0D, buf, sizeof(buf)));
	TEST_HEXDATA_EQUAL(
		"16030101250100012103035E786B64FD"
		"AA1421C01D2FE623865B7F8EDDAA0231"
		"E054DE18C587623D169EC100009EC02C"
		"C030009FC0ADC09FC024C028006BC00A"
		"C0140039C0AFC0A3C02BC02F009EC0AC"
		"C09EC023C0270067C009C0130033C0AE"
		"C0A200ABC0A7C03800B3C0360091C0AB"
		"00AAC0A6C03700B2C0350090C0AA009D"
		"C09D003D0035C032C02AC00FC02EC026"
		"C005C0A1009CC09C003C002FC031C029"
		"C00EC02DC025C004C0A000AD00B70095"
		"00AC00B6009400A9C0A500AF008DC0A9"
		"00A8C0A400AE008CC0A800FF0100005A"
		"0000000E000C0000093132372E302E30"
		"2E31000D001600140603060105030501"
		"040304010303030102030201000A0018"
		"00160019001C0018001B00170016001A"
		"0015001400130012000B000201000016"
		"00000017000000230000", buf, 298);
	return true;
}
